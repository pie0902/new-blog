---
title: '리눅스 커널 - 프로세스 관찰'
published: '2025-08-27T09:35:43.240Z'
tags: ['linux-kernel', 'process']
series: 'linux-kernel'
---

커널 구조를 공부해보자.

커널은 여러 가지 중요한 일을 하지만,
그중에서도 가장 기본은 "프로세스를 만들고 관리하는 것"이다.
오늘은 ps 명령어로 커널이 실제로 관리 중인 프로세스를 관찰해 보자.

## 프로세스 관리 (Process Management)

- `ps aux | head -10` 실행 → 실행 중인 프로세스 목록 관찰
- 출력 결과 해석 (PID 1 init, PID 2 kthreadd 등)
- **커널의 역할**: 프로세스 생성/스케줄링/종료 관리
  ***

## 1. `ps aux | head -10` 실행

![linux-ps](/images/linux-ps.png)

**첫 줄 (헤더)**

```sql
USER  PID  %CPU  %MEM  VSZ  RSS  TTY  STAT  START  TIME  COMMAND
```

1. USER: 프로세스를 실행한 사용자
2. PID: 프로세스 ID (고유번호)
3. %CPU / %MEM: CPU/메모리 사용량
4. VSZ / RSS: 가상 메모리 크기, 실제 물리 메모리 점유량
5. TTY: 연결된 터미널 (없으면 ?)
6. STAT: 현재 상태 (S=sleep, R=running, I=idle…)

**이제 위 정보를 바탕으로 해석을 해보자.**

- **루트 계정으로 실행됨**
  → 시스템 부팅 직후 가장 먼저 실행되는 **유저 공간 프로세스**라 root 권한으로 실행됨.
  → 이게 없으면 다른 프로세스들이 시작할 수 없음.
- **PID 1번**
  → 모든 프로세스의 “부모”.
  → 좀비 프로세스가 발생하면 최종적으로 init이 수거(reap)함.
- **CPU/MEM 사용량 없음**
  → init은 시스템 설정·서비스 실행 후에는 거의 대기 상태로 머무름.
  → 그래서 %CPU, %MEM이 0에 가까움.
- **VSZ/RSS = 315512 / 12516 (KB)**
  → 가상 메모리(315MB), 실제 점유 메모리(12MB).
  → 커널+서비스 관리 프로세스로는 가벼운 편.
  - VSZ = 315512 KB ≈ 308 MB (가상 메모리 크기)
  - RSS = 12516 KB ≈ 12 MB (실제 물리 메모리 점유)
- **TTY = ?**
  → 터미널과 연결된 게 아님.
  → 부팅 단계에서 백그라운드로 실행되었기 때문에 `?` 표시.
- **STAT = Ss**
  - **S** = Sleep (대기 중)
  - **s** = 세션 리더(session leader) → 다른 프로세스 그룹의 리더
    → 즉, init은 다른 서비스/데몬을 관리하는 “세션 리더” 역할.
- **START = 11:47**
  → 시스템 부팅 직후 실행됨 (시작 시간과 같음).
- **COMMAND = /sbin/init splash**
  → init 프로그램이 실행된 명령.
  → “splash” 옵션은 부팅할 때 로딩 화면(스플래시 화면)을 보여주라는 뜻.

PID 1 `/sbin/init splash`

- **리눅스 부팅 후 가장 먼저 실행되는 프로세스**
- root 권한으로 실행되고, 모든 프로세스의 부모
- 세션 리더로서 다른 서비스/데몬을 실행하고 관리
- CPU 사용률은 거의 0, 메모리 점유도 적음
- 터미널 연결은 없음 (`TTY=?`)

<aside>
하지만 우리의 목표는 빠른 학습, 아래 표로 정리해보겠다.

</aside>

| PID | COMMAND                | 종류               | 역할/설명                                                 |
| --- | ---------------------- | ------------------ | --------------------------------------------------------- |
| 1   | `/sbin/init splash`    | 유저 공간 프로세스 | 부팅 후 가장 먼저 실행되는 프로세스, 모든 프로세스의 부모 |
| 2   | `[kthreadd]`           | 커널 스레드        | 커널 스레드 관리자, 새로운 커널 스레드 생성·관리          |
| 3   | `[rcu_gp]`             | 커널 스레드        | RCU(Read-Copy-Update) 동기화 관리 (공유 데이터 접근 보장) |
| 4   | `[rcu_par_gp]`         | 커널 스레드        | 병렬 RCU 관련 스레드, RCU 작업을 병렬 처리                |
| 5   | `[slub_flushwq]`       | 커널 스레드        | SLUB 메모리 할당자 관련 워커 스레드, 메모리 관리          |
| 6   | `[netns]`              | 커널 스레드        | 네트워크 네임스페이스 관리 (컨테이너·가상 네트워크용)     |
| 9   | `[kworker/0:1-events]` | 커널 스레드        | 백그라운드 작업(worker) 처리, 하드웨어 이벤트 등          |
| 11  | `[mm_percpu_wq]`       | 커널 스레드        | 메모리 관리(mm) 관련 per-CPU 워커 스레드                  |
| 12  | `[rcu_tasks_kthread]`  | 커널 스레드        | RCU 관련 “tasks” 동기화 관리 (특정 태스크와 연계)         |

---

```
프로세스 관리 (커널 + 유저 프로세스)
├── 시작 & 부모
│   └── PID 1 : /sbin/init (모든 프로세스의 부모)
├── 스레드 관리
│   └── PID 2 : [kthreadd] (커널 스레드 관리자)
├── 동기화 (RCU 관련)
│   ├── PID 3 : [rcu_gp]
│   ├── PID 4 : [rcu_par_gp]
│   └── PID 12 : [rcu_tasks_kthread]
├── 메모리 관리
│   ├── PID 5  : [slub_flushwq]   (SLUB 메모리 할당자)
│   └── PID 11 : [mm_percpu_wq]   (메모리 per-CPU 워커)
├── 네트워크 관리
│   └── PID 6 : [netns] (네트워크 네임스페이스)
└── 이벤트/백그라운드
    └── PID 9 : [kworker/0:1-events] (이벤트 처리 워커)
```

> → 즉, init은 시작점, kthreadd는 관리자,
> rcu/slub/mm/netns/kworker는 각각 동기화·메모리·네트워크·이벤트를 담당한다.

### 🔹 커널의 역할

- **프로세스 생성** : `fork()`, `exec()` 같은 시스템콜을 통해 유저 공간 프로세스 생성
- **스케줄링** : CPU 시간을 공정하게 분배 (CFS 스케줄러 등)
- **종료 관리** : 프로세스가 끝나면 자원 해제, 좀비 프로세스는 init(PID 1)이 수거

---

### 오늘의 정리

오늘은 이 중에서 "이미 실행 중인 프로세스들이 커널에 의해 관리되고 있음"을
ps aux 출력으로 확인했다.
(fork/exec 과정을 직접 보는 건 다음 단계에서 strace 실습 예정)
