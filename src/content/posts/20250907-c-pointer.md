---
title: '리눅스 커널 - 시스템 콜'
published: '2025-09-07T18:30:00.240Z'
tags: ['C언어', '포인터']
series: 'C언어'
---

# C언어 포인터 다루기: 직접 만들어 본 연결 리스트

알고리즘 문제나 개발할 땐 늘 자바나 자바스크립트만 썼는데, C언어로도 뭔가 코딩하는 능력을 키워야겠다는 생각이 들었다. 일요일을 맞아 직접 IDE를 켜고, C언어의 꽃이라 불리는 포인터로 노드 리스트를 구현해봤다.

## 노드를 리스트 맨 앞에 추가하는 코드

~~~C

#include <stdio.h>
#include <stdlib.h>

/**
 * @struct Node
 * @brief 연결 리스트의 노드를 정의하는 구조체입니다.
 * * 각 노드는 정수 데이터를 저장하며, 다음 노드를 가리키는 포인터를 가집니다.
 * * typedef를 사용하여 'Node'라는 단순한 이름으로 사용할 수 있습니다.
 */
typedef struct Node {
    int val;
    struct Node *next;
} Node;
void add_list(Node **head,int val);
void free_list(Node *head);

int main(){
    Node *head = NULL;
    add_list(&head, 10);
    add_list(&head, 20);
    add_list(&head, 30);
    Node *cur = head;
    while(cur != NULL){
        printf("%d -> ", cur->val);
        cur = cur->next;
    }
    free_list(head);
    return 0;
}


void add_list(Node **head,int val){
    Node *new_node = (Node *)malloc(sizeof(Node));
    new_node->val = val;
    new_node->next = *head;
    *head = new_node;
}

void free_list(Node *head){
    Node *current = head;
    Node *next_node;
    while (current != NULL) {
        next_node = current->next;
        free(current);
        current = next_node;
    }
}
~~~


---
### 코드에서 느낀 궁금증

1. add_node 함수가 Node **head를 인자로 받는다.

2. 이건 Node *head라는 변수 자체의 주소를 받는다는 뜻이다.

3. head는 이미 포인터인데, 그 포인터의 주소를 또다시 포인터로 받는다는 사실에 혼란을 느꼈다.

4. 하지만 이 방식 덕분에 add_node 함수가 head 변수의 값을 직접 변경할 수 있게 된다.

### C언어 문법에서의 화살표 연산
~~~ C
new_node -> val = val;
~~~

이것은 (*new_node),val = val 이랑 비슷한 문법이라고 한다.
포인터 값을 다룰때 더 편하게 사용하려고 화살표 연산을 사용한다고 한다.

### 코드 뜯어보기
~~~ C
void add_list(Node **head,int val){
    Node *new_node = (Node *)malloc(sizeof(Node));
    new_node->val = val;
    new_node->next = *head;
    *head = new_node;
}
~~~

위 코드의 첫줄을 글로 표현해보겠다.
1. new_node라는 포인터 변수는
2. (Node *) 자료구조로 캐스팅 한다.
3. malloc(sizeof(Node)) = node의 크기만큼 메모리를 할당해줘 이다.

4. 그 다음에 방금 선언한 *new_node의 val 변수에는 매개변수로 받은 val
5. *new_node의 next는 head의 포인터 주소값을 넣는다.
6. *head의 주소값을 new_node로 설정한다. (현재 맨 앞에 있는 값을 맨 앞으로 바꾼다.) <- 우리가 head값을 다중포인터로 받은 이유이다. 주소 자체를 바꿔버리기 때문이다.


## 오늘의 정리
LeetCode에서 리스트 문제를 자바로 풀때는 메모리를 직접 할당받거나, 다중 포인터를 사용하지 않으니깐 저런 문제를 생각을 하지 않았다.

우리가 쓰는 편리한 언어들이 사실은 C언어의 이런 복잡한 작업들을 다 대신해준다는 걸 알게 됐다. 어렵긴 해도, 내부 동작을 이해할 수 있다는 게 진짜 큰 수확인 것 같다.