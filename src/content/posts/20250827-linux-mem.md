---
title: '리눅스 커널 - 메모리 관리'
published: '2025-08-27T09:35:43.240Z'
tags: ['linux-kernel', 'memory-management']
series: 'linux-kernel'
---

# 리눅스 커널 - 메모리 관리

## 메모리 관리 (Memory Management)

### 오늘의 목차

- `free -h` → 전체 메모리 요약 확인
- `cat /proc/meminfo | head -15` → 세부 항목 (캐시, 스왑, 버퍼 등) 관찰
- `vmstat 1 5` → 1초마다 5번 찍어서 메모리/CPU 변화를 실시간 관찰
  (프로그램 켰다 껐다 하면서 변하는 걸 볼 수 있음)

### 핵심 개념

- 가상 메모리: 각 프로세스는 자신만의 메모리 공간을 가진 것처럼 보임
  - 커널이 실제 물리 RAM과 매핑해줌
- 페이지(Page): 메모리를 작은 블록(보통 4kb)으로 쪼개서 관리
- 캐시/버퍼: 자주 쓰는 데이터는 미리 RAM에 올려둬서 속도 up
- 스왑(Swap): RAM이 부족하면 디스크 일부를 가짜 메모리처럼 사용

### 1. `free -h` 명령어 실습

```bash
free -h
```

| 구분          | total | used  | free  | shared | buff/cache | available |
| ------------- | ----- | ----- | ----- | ------ | ---------- | --------- |
| **Mem (RAM)** | 22Gi  | 2.5Gi | 17Gi  | 172Mi  | 2.3Gi      | 19Gi      |
| **Swap**      | 2.0Gi | 0B    | 2.0Gi | –      | –          | –         |

**해석**

- total: 전체 RAM 용량 = 22Gi
- used: 실제 사용 중인 메모리 = 2.5Gi
- free: 완전히 비어 있는 공간 = 17Gi
- shared: 여러 프로세스가 공유하는 메모리 = 172Mi
- buff/cache: 커널이 캐시/버퍼 용도로 확보해둔 메모리 = 2.3Gi
- avliable: 새로 프로그램 실행 시 실제 쓸 수 있는 여유 메모리 = 19Gi
- Swap: RAM이 부족할 때 대신 쓰는 디스크 영역, 지금은 하나도 안 씀

**요약**

- RAM 22Gi 중 실제 사용 중은 2.5Gi
- 커널이 캐시로 2.3Gi 잡아둠 → 필요하면 바로 해제해서 사용 가능
- 그래서 프로그램들이 새로 쓸 수 있는 실제 여유 공간은 19Gi정도 됨

<aside>

여기서 표에 나오는 단위는 GiB(2의 제곱 단위)다. 흔히 쓰는 GB와는 조금 달라서, 22 GiB는 약 23.6 GB에 해당한다.

</aside>

### 2.`cat /proc/meminfo | head -15` 실습

```bash
cat /proc/meminfo | head -15
```

| 항목               | 값                       | 의미                                                   |
| ------------------ | ------------------------ | ------------------------------------------------------ |
| **MemTotal**       | 23,383,944 kB ≈ 22.3 GiB | 전체 물리 메모리                                       |
| **MemFree**        | 17,910,092 kB ≈ 17.1 GiB | 완전히 비어 있는 RAM                                   |
| **MemAvailable**   | 19,794,024 kB ≈ 18.9 GiB | 실제로 새 프로그램 실행 시 사용 가능한 RAM             |
| **Buffers**        | 146,016 kB ≈ 142 MB      | 블록 장치 I/O 버퍼                                     |
| **Cached**         | 2,097,428 kB ≈ 2.0 GiB   | 파일 캐시 (최근 읽은 파일을 메모리에 보관)             |
| **SwapCached**     | 0 kB                     | 스왑에 갔다가 다시 RAM으로 돌아온 페이지 (지금은 없음) |
| **Active**         | 3,545,676 kB ≈ 3.4 GiB   | 최근에 사용된, 곧 다시 쓰일 가능성이 높은 메모리       |
| **Inactive**       | 1,238,532 kB ≈ 1.2 GiB   | 최근에 안 쓰였지만 필요하면 곧 해제될 수 있는 메모리   |
| **Active(anon)**   | 2,562,088 kB ≈ 2.4 GiB   | 프로세스 힙/스택 같은 익명 메모리 중 ‘활성’ 상태       |
| **Inactive(anon)** | 93,688 kB ≈ 91 MB        | 익명 메모리 중 비활성                                  |
| **Active(file)**   | 983,588 kB ≈ 960 MB      | 파일과 매핑된 메모리 중 활성                           |
| **Inactive(file)** | 1,144,844 kB ≈ 1.1 GiB   | 파일과 매핑된 메모리 중 비활성                         |
| **Unevictable**    | 16 kB                    | 스왑 불가, 반드시 RAM에 있어야 하는 페이지             |
| **Mlocked**        | 16 kB                    | 프로세스가 `mlock()`으로 잠가둔 메모리 (스왑 불가)     |
| **SwapTotal**      | 2,097,148 kB ≈ 2.0 GiB   | 전체 스왑 공간                                         |

---

**요약**

- **MemAvailable (≈19 GiB)** → 앞으로 쓸 수 있는 여유 메모리
- **Buffers + Cached (≈2.1 GiB)** → 캐시로 잡혀 있지만 필요하면 곧바로 환원 가능
- **Active/Inactive** → 메모리 페이지가 얼마나 최근에 쓰였는지
- **SwapTotal = 2 GiB** → 스왑 공간 설정돼 있음, 지금은 사용 안 함

### 3.`vmstat 1 5` 명령어 실습

- **`vmstat`** → Virtual Memory Statistics, 커널이 관리하는 **프로세스/메모리/스왑/IO/CPU** 상태를 요약해 보여주는 명령어
- **`1`** → 출력 간격 = 1초마다
- **`5`** → 출력 횟수 = 총 5번 찍고 종료

```bash
vmstat 1 5
```

## `vmstat` 출력 항목 정리

| 구분       | 항목  | 의미                                     | 네 출력값(대략)          | 해석                         |
| ---------- | ----- | ---------------------------------------- | ------------------------ | ---------------------------- |
| **procs**  | r     | 실행 대기 프로세스 수                    | 0~1                      | CPU 대기열 거의 없음         |
|            | b     | I/O 대기 프로세스 수                     | 0~1                      | 블록 상태 거의 없음          |
| **memory** | swpd  | 사용 중인 스왑 메모리(KB)                | 0                        | 스왑 안 씀 (RAM 충분)        |
|            | free  | 사용 가능한 RAM(KB)                      | ~18,300,000 KB (≈18 GiB) | 메모리 여유 충분             |
|            | buff  | 버퍼 캐시(KB)                            | ~148,000 KB (≈148 MB)    | 블록 I/O 버퍼                |
|            | cache | 페이지 캐시(KB)                          | ~2,200,000 KB (≈2.2 GiB) | 파일 캐시                    |
| **swap**   | si    | swap-in (디스크→RAM)                     | 0                        | 없음                         |
|            | so    | swap-out (RAM→디스크)                    | 0                        | 없음                         |
| **io**     | bi    | 블록 입력(KB/s)                          | 0~13                     | 디스크 읽기 거의 없음        |
|            | bo    | 블록 출력(KB/s)                          | 0~556                    | 디스크 쓰기 거의 없음        |
| **system** | in    | 인터럽트 횟수(/s)                        | 1,000~1,300              | 정상 범위                    |
|            | cs    | 컨텍스트 스위치(/s)                      | 1,600~2,000              | CPU 태스크 전환 빈도         |
| **cpu**    | us    | 유저 CPU 사용률                          | 1~2%                     | 유저 프로그램 CPU 사용 낮음  |
|            | sy    | 커널 CPU 사용률                          | 0~1%                     | 커널 부하 낮음               |
|            | id    | idle(노는 비율)                          | 98~99%                   | CPU 거의 놀고 있음           |
|            | wa    | I/O wait                                 | 0%                       | 디스크 병목 없음             |
|            | st    | steal (가상화에서 다른 VM이 훔쳐간 시간) | 0%                       | 물리 머신/VM에서도 부하 없음 |

---

**요약**

- **CPU**: idle 98~99% → 거의 놀고 있음
- **메모리**: free 18 GiB, 캐시 2.2 GiB → 매우 여유
- **Swap**: 사용 안 함 → 성능 문제 없음
- **I/O**: 입출력 미미, 병목 없음
- **System**: 인터럽트/컨텍스트 스위치 정상

### 정리

오늘은 3개의 명령어에 대해서 공부하고 결과를 분석해봤다.

하지만 더 와닿게 이해하려면 저 명령어를 사용하는 가상의 상황이 필요할 것 같다.

예를들어서 내 디렉토리에 뭐가있지? 할때 `ls -a` 명령어를 사용하는 것 처럼 말이다.

- 가상 상황
  - 평소엔 잘 쓰던 Ubuntu 노트북이 갑자기 버벅인다.
  - 웹 브라우저를 열면 탭 전환이 느리고, 스크롤도 끊긴다.
  - 원인이 **메모리 문제인지, CPU 문제인지** 확인해야 한다.
- 해결 과정
  - **`free -h` 실행**
    - `available` 메모리가 아주 적고, `swap` 사용량이 올라가 있음을 확인
    - → RAM이 부족해서 디스크 스왑을 쓰는 중일 수 있다.
  - **`cat /proc/meminfo | head -15` 실행**
    - `Cached` 값이 너무 크고, `SwapFree`가 줄어 있는 걸 확인
    - → 커널이 디스크에 스왑을 쓰면서 캐시 공간도 과도하게 차지하는 상황
  - **`vmstat 1 5` 실행**
    - `si/so` 값이 계속 증가 (swap in/out 활발)
    - `wa`(I/O wait)도 높아짐 (디스크 병목)
    - → CPU는 한가한데 디스크 I/O 때문에 전체 시스템이 느려진 것임을 알 수 있음
- 결론
  - 브라우저가 느려진 이유는 CPU가 아니라 **메모리 부족 → 스왑 사용 → 디스크 병목**때문. 이때 해결책은 **불필요한 앱 종료, RAM 업그레이드, swap 조정** 등이 됨

올바르게 공부하려면 기초가 정말 중요하다.

학교 수업이나 자격증 공부를 통해 커널이라는 개념을 접하긴 했지만, 막상 깊이 이해하지 못한 채 넘어간 경우가 많았다.

이번에는 리눅스에서 직접 명령어를 실행해 보면서 눈으로 확인하고 기록하는 방식으로 공부하고 있는데, 확실히 체감도 되고 이해도 훨씬 잘 된다.

다만 가끔은 **“이런 식으로 하나하나 명령어를 실행하며 커널 내부를 보는 공부 방향이 정말 올바른 걸까?”** 하는 의문도 든다.

그럼에도 불구하고, 지금처럼 기초를 직접 손으로 다루고 정리하는 과정이야말로 커널을 이해하는 가장 확실한 출발점이라고 믿고 싶다.
