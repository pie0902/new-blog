---
title: '리눅스 커널 - 커널이란?'
published: '2025-08-26T09:35:43.240Z'
tags: ['linux-kernel']
series: 'linux-kernel'
---

# 리눅스 커널 - 커널이란?

## 리눅스 커널이란?

- 운영체제의 핵심 부분
- HW ↔ SW 사이의 증간층
- 운영체제의 핵심 부분으로, 하드웨어(HW)와 소프트웨어(SW) 사이에서 다리를 놓아주는 역할을 한다.
- 우리가 실행하는 프로그램이 직접 하드웨어를 다루지 않고도 동작할 수 있게, 커널이 모든 자원을 관리하고 조율한다.

## 주요 구성

- **Process Management** (스케줄링, 컨텍스트 스위칭)
  - 스케줄링: 어떤 프로세스를 CPU에 실행시킬지 결정하는 기능
  - 컨텍스트 스위칭: 실행 중인 프로세스를 다른 프로세스로 바꿔주는 과정
- **Memory Management** (가상 메모리, 페이지)
  - 가상 메모리: 각 프로세스가 독립된 메모리 공간을 가진 것처럼 보이게 하는 기술
  - 페이지: 메모리를 작은 블록으로 나누어 관리하는 단위
- **File System (VFS)** (모든 파일 시스템을 통합하는 레이어)
  - VFS: ext4, FAT, NTFS 같은 다양한 파일 시스템을 하나의 공통 인터페이스로 묶어주는 계층
- **Device Driver** (HW 제어)
  - 디바이스 드라이버: 커널이 하드웨어(키보드, 디스크, 네트워크 카드 등)를 제어할 수 있게 해주는 소프트웨어

## 커널 부팅 로그 살펴보기

리눅스 커널이 실제로 어떻게 동작하는지 확인할 수 있는 방법 중 하나가 dmesg 명령어다.

dmesg는 커널이 부팅하면서 찍은 로그를 보여주는데, 여기에는 CPU, 메모리, 드라이버 초기화 과정 등이 담겨 있다.

명령어를 정리해보겠다.(feat.chatGPT)

| 명령어               | 설명                                         |
| -------------------- | -------------------------------------------- |
| `uname -r`           | 현재 실행 중인 커널 버전 확인                |
| `uname -a`           | 커널 전체 정보(버전, 빌드 일시, 아키텍처 등) |
| `cat /proc/version`  | 커널 버전 + 빌드된 gcc/ld 정보 확인          |
| `sudo dmesg \| less` | 부팅 로그 및 커널 메시지 확인 (root 필요)    |
| `lsmod`              | 현재 로드된 커널 모듈 리스트 확인            |
| `modinfo <모듈명>`   | 특정 모듈의 상세 정보 확인                   |
| `strace <명령어>`    | 사용자 프로그램이 호출하는 system call 추적  |

한번씩 직접 터미널에 입력해보고 기록해보자!

## 직접 입력해보기

### 1. uname -r

```bash
uname -r
```

### 결과

```
6.5.0-26-generic
```

### 이게 뜻하는 것

`6.5.0-26-generic` 은 지금 컴퓨터에서 실행 중인 **리눅스 커널의 버전 이름표**다.

버전 번호는 다음과 같이 나눠서 읽을 수 있다:

| 부분        | 의미                                  | 비유                                  |
| ----------- | ------------------------------------- | ------------------------------------- |
| **6**       | 큰 세대 번호 (Major)                  | 안드로이드 13 → 14처럼 큰 판올림      |
| **5**       | 중간 업그레이드 번호 (Minor)          | 소규모 기능 추가                      |
| **0**       | 작은 수정 번호 (Patch)                | 버그 패치 수준                        |
| **26**      | 배포용 패치 번호 (Ubuntu가 붙인 버전) | 우분투 맞춤 업데이트                  |
| **generic** | 일반 PC용 커널                        | 서버/특수 하드웨어용이 아닌 기본 버전 |

쉽게 말해, **“리눅스 커널 6학년 5반 0번 — 26번째 수정판 (일반반)”** 같은 이름표라고 보면 된다.

### 2. uname -a

```bash
uname -a
```

### 결과

```
Linux thunder 6.5.0-26-generic #26~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Mar 12 10:22:43 UTC 2 x86_64 x86_64 x86_64 GNU/Linux
```

### 이게 뜻하는 것

`uname -a`는 **커널과 시스템의 전체 정보를 한 줄로 보여주는 명령어**다.

| 부분                          | 의미                                                |
| ----------------------------- | --------------------------------------------------- |
| **Linux**                     | 운영체제 커널 이름                                  |
| **thunder**                   | 호스트 이름(내 PC 이름)                             |
| **6.5.0-26-generic**          | 커널 버전 (앞에서 본 것과 동일)                     |
| **#26~22.04.1-Ubuntu**        | 우분투에서 빌드한 커널 릴리즈 번호                  |
| **SMP**                       | Symmetric Multi Processing 지원 (멀티코어 CPU 지원) |
| **PREEMPT_DYNAMIC**           | 커널 선점(Preemption) 모드가 동적으로 조정 가능     |
| **Tue Mar 12 10:22:43 UTC 2** | 커널이 빌드된 날짜와 시간                           |
| **x86_64 x86_64 x86_64**      | 64비트 커널, 64비트 머신, 64비트 사용자 공간        |
| **GNU/Linux**                 | GNU 툴체인 + 리눅스 커널 조합으로 된 운영체제       |

즉, `uname -a`는 **“내 커널이 어떤 버전인지, 언제 빌드됐고, 어떤 환경에서 돌아가는지”**를 한눈에 보여준다.

### 3. cat /proc/version

```bash
cat /proc/version
```

### 결과

```
Linux version 6.5.0-26-generic (buildd@lcy02-amd64-051) (x86_64-linux-gnu-gcc-12 (Ubuntu 12.3.0-1ubuntu1~22.04) 12.3.0, GNU ld (GNU Binutils for Ubuntu) 2.38) #26~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Mar 12 10:22:43 UTC 2
```

### 이게 뜻하는 것

`cat /proc/version`은 커널이 **어떻게 빌드되었는지**를 보여준다.

출력에는 `uname -a`와 겹치는 정보도 있지만, 몇 가지 차이점이 있다:

| 부분                                                      | 의미                                                   |
| --------------------------------------------------------- | ------------------------------------------------------ |
| **Linux version 6.5.0-26-generic**                        | 실행 중인 커널 버전                                    |
| **buildd@lcy02-amd64-051**                                | 커널을 빌드한 빌드 서버/사용자 정보                    |
| **x86_64-linux-gnu-gcc-12 (Ubuntu 12.3.0-1...)**          | 커널을 컴파일할 때 사용된 gcc 버전                     |
| **GNU ld (Binutils 2.38)**                                | 링커(ld) 버전                                          |
| **#26~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Mar 12 ...** | 빌드 번호, SMP(멀티코어 지원), PREEMPT 옵션, 빌드 시각 |

정리하면:

- `uname -a` → 지금 실행 중인 커널의 **실행 환경 정보**
- `cat /proc/version` → 이 커널이 어떤 **컴파일러/도구 체인으로 빌드됐는지**

### 3. sudo dmesg | less

- 출력이 수백 줄 이상이라 블로그에 전부 담기엔 부담스럽다.
- 다음에 따로 다뤄보는게 좋을 것 같다.
- 부팅 로그 및 커널 메시지를 확인할 수 있다.
- 뒷부분(드라이버 로딩, 네트워크 초기화 등)은 나중에 별도로 다루는 게 좋다.

### 4. lsmod

```bash
lsmod
```

### 결과 (일부)

```
Module           Size    Used by
snd_usb_audio    450560  3
btusb            73728   0
uvcvideo         135168  0
amdgpu           15552512 26
rtw88_core       356352  2
thinkpad_acpi    159744  0
r8169            114688  0
nvme             57344   2
```

### 이게 뜻하는 것

- **snd_usb_audio** → USB 오디오 장치 드라이버
- **btusb** → 블루투스 USB 드라이버
- **uvcvideo** → 웹캠 드라이버
- **amdgpu** → AMD 그래픽카드 드라이버
- **rtw88_core** → Realtek Wi-Fi 드라이버
- **thinkpad_acpi** → ThinkPad 전용 ACPI 기능 드라이버
- **r8169** → Realtek 유선랜 드라이버
- **nvme** → NVMe SSD 드라이버

`lsmod`는 **커널이 지금 어떤 드라이버 모듈을 로드했는지** 확인하는 명령어다.

- `smod`에 나오는 450560 같은 숫자는 모듈의 메모리 크기(바이너리 크기, 바이트 단위)

### 5. `modinfo <모듈명>`

위에서 나온 모듈을 넣어보겠다.

- rtw88_core: 리얼텍(Realtek) 무선랜 칩셋 드라이버의 핵심(core) 모듈

명령어를 입력하면 특정 모듈에 대한 상세 정보를 확인할 수 있다.

```bash
modinfo rtw88_core
```

### 결과 (요약)

| 항목            | 의미                                                            |
| --------------- | --------------------------------------------------------------- |
| **filename**    | `/lib/modules/.../rtw88_core.ko` → 모듈 파일 경로               |
| **license**     | Dual BSD/GPL → 리눅스 커널에 적합한 라이선스                    |
| **description** | Realtek 802.11ac wireless core module                           |
| **author**      | Realtek Corporation                                             |
| **depends**     | mac80211, cfg80211 → 리눅스 무선 네트워크 스택 의존             |
| **vermagic**    | 6.5.0-26-generic SMP preempt ... (빌드된 커널 버전/옵션)        |
| **parm**        | `disable_lps_deep`, `support_bf`, `debug_mask` 등 모듈 파라미터 |

### 정리

- **rtw88_core**: 리얼텍(Realtek) 무선랜 칩셋 드라이버의 핵심(core) 모듈
- `rtw88` → Realtek Wi-Fi 드라이버 계열 이름
- `_core` → 여러 변종 칩셋(`rtw88_8822c`, `rtw88_8822ce` 등)을 공통으로 지원하는 핵심 로직
- 실제로는 `rtw88_core`와 칩셋별 모듈(`rtw88_8822c`, `rtw88_pci` 등)이 함께 로드되어 동작
- 목적: **리눅스에서 Realtek Wi-Fi 카드가 정상적으로 동작하도록 지원**

### 6. strace

```bash
strace ls
```

### 결과 (일부 발췌)

```
execve("/usr/bin/ls", ["ls"], ...) = 0
openat(AT_FDCWD, ".", O_RDONLY|O_DIRECTORY) = 3
getdents64(3, /* 10 entries */, 32768) = 400
write(1, "hello.txt\n", 10) = 10
```

### 이게 뜻하는 것

- **execve** → `ls` 프로그램 실행 시작
- **openat** → 현재 디렉토리 열기
- **getdents64** → 디렉토리 안 파일 목록 읽기
- **write** → 읽은 내용을 터미널에 출력

정리: **strace는 "유저 프로그램이 커널에 어떤 요청을 하는지" 보여주는 도구다.**

---

## 오늘의 정리

리눅스 커널을 공부하는 목적은 여러 가지가 있지만, 그중에서도 가장 큰 이유는 **리눅스의 내부 동작 원리를 깊이 이해하고 싶기 때문**이다.

자격증 공부나 학교 수업에서 운영체제를 배울 때는 단순히 _“커널은 운영체제의 핵심이다”_ 정도로만 알고 넘어갔었다. 하지만 실제로는 그 안에서 얼마나 많은 일들이 일어나는지 제대로 알지 못했다.

오늘 `strace` 명령어를 사용해 보면서 큰 충격을 받았다. 우리가 무심코 사용하는 `ls` 같은 간단한 명령어조차, 내부적으로는 수많은 **시스템 콜**과 **커널의 처리 과정**을 거쳐 실행된다는 사실을 눈으로 확인했기 때문이다.

겉으로는 단순히 “현재 디렉토리의 파일을 보여준다”라는 결과만 보이지만, 그 뒤에서는 수많은 프로세스가 메모리를 할당하고, 라이브러리를 불러오고, 파일 시스템과 커널이 협력하여 일을 처리하고 있었다.

평소에 너무 당연하게 쓰던 명령어들이 사실은 이렇게 복잡한 과정을 통해 동작한다는 것을 알게 되니, 운영체제와 커널의 정교함이 새삼 대단하게 느껴진다.
